import lat.LatVar;

import lat.LatVarList;
import lat.LatVarRange;
import lat.LatVarOmp;

import lat.LatConsts;
import lat.LatUtils;

import lara.Io;

import clava.Clava;

var Lat = function(name, scope, variables, measure, searchType, numTests, clearCode, verbose, abort, timeout, outputPath) {
    this.loadDefaults(name, scope, variables, measure, searchType, numTests, clearCode, verbose, abort, timeout, outputPath);
    this.tunned = false; //set to true after a tuning execution
};

Lat.prototype.tune = function() {
    if (this.searchType === LatConst.SEARCH_TYPE.DEPENDENT || this.searchType === LatConst.SEARCH_TYPE.INDEPENDENT) {
        this.variables = LatUtils.removeDuplicates(this.variables);
    }
    this.generateSearchGroups();
    this.generateUniqueVariables();
};


Lat.prototype.toConfig = function(filename) {
    filename = LatUtils.getRightExtension(filename, "json");
    Io.writeJson(filename, this);
    writeFile(filename, JSON.stringify(this));
};

Lat.prototype.fromConfig = function(filename) {
    LatUtils._error("function fromConfig not implemented, missing 'this[property]' access");
    var temp = Io.readJson(filename);
    for (var property in temp) {
        //println("property: " + property + " = " + temp[property]);
        //TODO: check it works after fixing this[property]
        //this[property] = temp[property];
    }
};

Lat.prototype.countVariants = function() {
    var count = 0;
    if (this.searchType == LatConst.SEARCH_TYPE.DEPENDENT) {
        //dependent search means for every var, every other's value will be used -> product
        count = 1;
        for (var i = 0; i < this.variables.length; i++) {
            count *= this.variables[i].countElements();
        }
    } else if (this.searchType == LatConst.SEARCH_TYPE.INDEPENDENT) {
        //independent search iterates a single variable while keeping all the others constant -> sum
        for (var i = 0; i < this.variables.length; i++) {
            count += this.variables[i].countElements();
        }
    } else if (this.searchType == LatConst.SEARCH_TYPE.CUSTOM) {
        //each search group acts as a dependent search, and between search groups the pattern is dependent
        for (var i = 0; i < this.searchGroups.length; i++) {
            var temp = 1;
            for (var j = 0; j < this.searchGroups[i].length; j++) {
                temp *= this.searchGroups[i][j].countElements();
            }
            count += temp;
        }
    }
    return count;
};

Lat.prototype.estimateTime = function() {
    LatUtils._error("function estimateTime not implemented");
};

//--------------------------------------------Setters

Lat.prototype.setName = function(name) {
    LatUtils.checkString(name, "name");
    this.name = name;
    return this;
};
Lat.prototype.setScope = function(scope) {
    LatUtils.checkJoinpoint(scope, "scope");
    this.scope = scope;
    return this;
};
Lat.prototype.setMeasure = function(measure) {
    LatUtils.checkJoinpoint(measure, "measure");
    this.measure = measure;
    return this;
};
Lat.prototype.setVariables = function(variables) {
    LatUtils.checkLatVars(variables, "variables");
    LatUtils.checkDuplicatesLatVar(variables, "variables");
    this.variables = variables;
    return this;
};
Lat.prototype.addVariable = function(latVar) {
    LatUtils.checkLatVar(latVar, "latVar in addVariable");
    LatUtils.checkDuplicateLatVar(this.variables, latVar, "variables");
    this.variables.push(latVar);
    return this;
};
Lat.prototype.setSearchGroups = function(searchGroups) {
    for (var i = 0; i < searchGroups.length; i++) {
        LatUtils.checkLatVars(searchGroups[i], "searchGroups[" + i + "]");
    }
    this.searchGroups = searchGroups;
    this.searchType = LatConst.SEARCH_TYPE.CUSTOM;
    return this;
};
Lat.prototype.addSearchGroup = function(searchGroup) {
    LatUtils.checkLatVars(searchGroup, "searchGroup(addSearchGroup)");
    this.searchGroups.push(searchGroup);
    this.searchType = LatConst.SEARCH_TYPE.CUSTOM;
    return this;
};
Lat.prototype.setSearchType = function(searchType) {
    if (searchType !== LatConst.SEARCH_TYPE.INDEPENDENT && searchType !== LatConst.SEARCH_TYPE.DEPENDENT) {
        LatUtils._error("setSearchType only accepts LatConst.SEARCH_TYPE.INDEPENDENT and LatConst.SEARCH_TYPE.DEPENDENT, see the documentation on how to specify LatConst.SEARCH_TYPE.CUSTOM");
    }
    this.searchGroups = []; //will be generated when tune() is called
    this.searchType = searchType;
    return this;
};
Lat.prototype.setNumTests = function(numTests) {
    if (numTests <= 0) {
        LatUtils._error("numTests has to be an int greater or equal to 1, invalid value (" + numTests + ")");
    }
    this.numTests = numTests;
    return this;
};

//TODO: check if this will be exposed
Lat.prototype.setCompiler = function(compiler) {
    this.compiler = compiler;
    return this;
};

Lat.prototype.setClearCode = function(clearCode) {
    LatUtils.checkBoolean(clearCode, "clearCode");
    this.clearCode = clearCode;
    return this;
};
Lat.prototype.setVerbose = function(verbose) {
    LatUtils.checkBoolean(verbose, "verbose");
    this.verbose = verbose;
    return this;
};
Lat.prototype.setAbort = function(abort) {
    LatUtils.checkBoolean(abort, "abort");
    this.abort = abort;
    return this;
};
Lat.prototype.setTimeout = function(timeout) {
    if (numTests < 0) {
        LatUtils._error("timeout has to be an unsigned int, invalid value (" + timeout + ")");
    }
    this.timeout = timeout;
    return this;
};
//TODO: validate path
Lat.prototype.setOutputPath = function(outputPath) {
    this.outputPath = outputPath;
    return this;
};

//--------------------------------------------Helper functions (code compartimentalization)

Lat.prototype.loadDefaults = function(name, scope, variables, measure, searchType, numTests, clearCode, verbose, abort, timeout, outputPath) {
    //requried values
    this.name = this.validateProperty("name", name);
    this.scope = this.validateProperty("scope", scope);

    //optional values
    this.variables = this.validateProperty("variables", variables, []);
    this.measure = this.validateProperty("measure", measure, scope);
    this.searchType = this.validateProperty("searchType", searchType, LatConst.SEARCH_TYPE.INDEPENDENT);
    this.numTests = this.validateProperty("numTests", numTests, 1);
    this.clearCode = this.validateProperty("clearCode", clearCode, false);
    this.verbose = this.validateProperty("verbose", verbose, false);
    this.abort = this.validateProperty("abort", abort, false);
    this.timeout = this.validateProperty("timeout", timeout, 0);
    //TODO: fill with correct default value
    this.outputPath = this.validateProperty("outputPath", outputPath, ".");
};

/**
 * Return either the correct value or the default value for a given property
 */
Lat.prototype.validateProperty = function(propertyName, value, defaultValue) {
    /*TODO: use this[propertyName]
    
    if (defaultValue === undefined && value === undefined) {
        LatUtils._error("The value specified for the property '" + propertyName + "' is undefined and it is a required property");
    }*/
    if (value === undefined) {
        value = defaultValue;
    }
    return value;
};

/**
 * Generate the searchGroups for dependent and independent search
 */
Lat.prototype.generateSearchGroups = function() {
    if (this.searchType === LatConst.SEARCH_TYPE.INDEPENDENT) {
        this.searchGroups = [];
        for (var i = 0; i < this.variables.length; i++) {
            this.searchGroups.push([this.variables[i]]);
        }
    } else if (this.searchType === LatConst.SEARCH_TYPE.DEPENDENT) {
        this.searchGroups = this.variables;
    }
    return this;
};
/**
 * create a list of unique variables from search groups for the custom searchtype, or return this.variables for the other cases 
 */
Lat.prototype.generateUniqueVariables = function() {
    this.uniqueVariables = [];
    if (this.searchType === LatConst.SEARCH_TYPE.CUSTOM) {
        for (var i = 0; i < this.searchGroups.length; i++) { //iterate all search groups
            for (var j = 0; j < this.searchGroups[i].length; j++) { //iterate all variables in a search group
                this.uniqueVariables.push(this.searchGroups[i][j]);
            }
        }
        this.uniqueVariables = LatUtils.removeDuplicates(this.uniqueVariables);
    } else {
        this.uniqueVariables = this.variables;
    }
    this.uniqueVariables = this.uniqueVariables.map( //back referencing the index
        function(x, i) {
            x.index = i;
            return x;
        });
    return this;
};

/**
 * Creates an array with the exact number of objects as there are unique variables, to be used as a stub further along the program
 */
    for (var i = 0; i < this.uniqueVariables.length; i++) {
    }
    return this;
};

/**
 */
    for (var i = 0; i < this.searchGroups.length; i++) {
    }
    print();
                print("0 - ");
            } else {
            }
        }
        println();
    }
    return this;
};

/**
 * 
 * @param searchGroup a list with the LatVars of the current searchGroup
 * @param current 
 * @param index
 */
    //the searchGroup[index].index is to keep the same variable in the same position, always, according to this.uniqueVariables
    while (searchGroup[index].hasNext()) {
        return;
        if ((index + 1) < searchGroup.length) {
            println("next");
        } else {
            println("no next");
            while (searchGroup[index].hasNext()) {
            }
            searchGroup[index].restart();
        }
    }
    /*
    if (searchGroup[index].hasNext()) {
        //the searchGroup[index].index is to keep the same variable in the same position, always, according to this.uniqueVariables
        index++; //next LatVar in the searchGroup
        if (index < searchGroup.length) {
        } else {
            while (searchGroup[index].hasNext()) {
            }
            searchGroup[index].restart();
        }
    }
    */
};

var outs = function(a) {
    println(JSON.stringify(a));
};