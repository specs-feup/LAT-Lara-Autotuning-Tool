var LatUtils = {};

LatUtils._error = function(message) {
    throw new Error("Lat error: " + message);
};

LatUtils._warn = function(message) {
    println("Lat warning: " + message);
};

/**
 * Return a file name with the extension passed, only changes filename if this condition is not met
 * @param filename the original filename
 * @param extension the extension to force (without the '.', eg. 'json')
 * @return filename altered if necessary to end in the specified extension, it will be appended if necessary
 */
LatUtils.getRightExtension = function(filename, extension) {
    var realExtension = filename.split('.').pop();
    if (realExtension != extension) {
        filename += "." + extension;
    }
    return filename;
};


//validation functions
//TODO: guarantee that scope and measure are only joinpoints that can have insert before and after
LatUtils.isJoinpoint = function(variable) {
    return typeof variable === LatConst.TYPE.OBJECT && variable.type == LatConst.TYPE.JOINPOINT;
};
LatUtils.checkJoinpoint = function(variable, name) {
    if (!LatUtils.isJoinpoint(variable)) {
        LatUtils._error(name + " variable requires a joinpoint - invalid type supplied");
    }
};

LatUtils.isBoolean = function(variable) {
    return typeof variable === LatConst.TYPE.BOOLEAN;
};
LatUtils.checkBoolean = function(variable, name) {
    if (!LatUtils.isBoolean(variable)) {
        LatUtils._error(name + " variable has to be a boolean - invalid value supplied");
    }
};

LatUtils.isNumber = function(variable) {
    return typeof variable === LatConst.TYPE.NUMBER;
};
LatUtils.checkNumber = function(variable, name) {
    if (!LatUtils.isNumber(variable)) {
        LatUtils._error(name + " variable has to be a number - invalid value supplied");
    }
};

LatUtils.isString = function(variable) {
    return typeof variable === LatConst.TYPE.STRING;
};
LatUtils.checkString = function(variable, name) {
    if (!LatUtils.isString(variable)) {
        LatUtils._error(name + " variable has to be a string - invalid value supplied");
    }
};

LatUtils.isArray = function(variable) {
    return variable instanceof Array;
};
LatUtils.checkArray = function(variable, name) {
    if (!LatUtils.isArray(variable)) {
        LatUtils._error(name + " variable has to be an array - invalid value supplied");
    }
};

LatUtils.isLatVar = function(variable) {
    return variable instanceof LatVar;
};
LatUtils.checkLatVar = function(variable, name) {
    if (!LatUtils.isLatVar(variable)) {
        LatUtils._error("element " + name + " has to be a LatVar or one of its children (LatVarList, LatVarRange, LatVarOmp) to be passed - invalid value supplied");
    }
};
LatUtils.checkLatVars = function(variables, name) {
    LatUtils.checkArray(variables, name);
    for (var i = 0; i < variables.length; i++) {
        LatUtils.checkLatVar(variables[i], name + "[" + i + "]");
    }
};

LatUtils.checkDuplicateLatVar = function(latVars, latVar, listName) {
    for (var i = 0; i < latVars.length; i++) {
        if (latVar.equals(latVars[i])) {
            LatUtils._error("LatVar: " + latVar.name + " cannot appear more than once in the list " + listName + "(matches the element at position " + i + ")");
        }
    }
};
LatUtils.checkDuplicatesLatVar = function(latVars, listName) {
    for (var i = 0; i < latVars.length; i++) {
        for (var j = 0; j < latVars.length; j++) {
            if (i != j) {
                if (latVars[i].equals(latVars[j])) {
                    LatUtils._error("LatVar: " + latVars[i].name + " cannot appear more than once in the list " + listName + "(matches the element at positions " + i + " and " + j + ")");
                }
            }
        }
    }
};

/**
 * Remove duplicates from a javascript array
 * @param list the initial array
 * @return an array with all the unique elements of list
 */
LatUtils.removeDuplicates = function(list) {
    var seen = {};
    return list.filter(function(item, pos) {
        return list.indexOf(item) == pos;
    });
};
/**
 * Remove duplicates from a javascript array that contains cloned items, the default removeDuplicates won't work
 * @param list the initial array
 * @return an array with all the unique elements of list
 */
LatUtils.removeDuplicatesCloned = function(list) {
    var seen = {};
    return list.filter(function(item, pos) {
        return LatUtils.indexOf(list, item) == pos;
    });
};

LatUtils.indexOf = function(array, item) {
    for (var i = 0; i < array.length; i++) {
        if (JSON.stringify(array[i]) === JSON.stringify(item)) {
            return i;
        }
    }
    return -1;
};

/**
 * clone and return the cloned version of an object
 * @param obj the object to clone
 * @return cloned version of obj
 */
LatUtils.clone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
};

/**
 * calculate the sum of an array of integers
 * @param list the array of integers
 * @return the sum of all the elements in list
 */
LatUtils.sum = function(list) {
    var sum = 0;
    for (var i = 0; i < list.length; i++) {
        sum += parseInt(list[i], 10); //don't forget to add the base
    }
    return sum;
};

/**
 * calculate the average of an array of integers
 * @param list the array of integers
 * @return the avgerage of all the elements in list
 */
LatUtils.avg = function(list) {
    return LatUtils.sum(list) / list.length;
};