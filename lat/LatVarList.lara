var LatVarList = function(name, elements, type) {
    LatVar.call(this, name, type);
    LatUtils.checkArray(elements, "LatVarList elements");
    if (elements.length <= 0) {
        LatUtils._error("LatVarList elements parameter only accepts non-empty element lists");
    }
    this.elements = elements;
    this.restart();
};

LatVarList.prototype = Object.create(LatVar.prototype);
LatVarList.prototype.constructor = LatVarList;

//Functions overloaded from LatVar

LatVarList.prototype.getNext = function() {
    if (this.first) {
        this.first = false;
        return LatUtils.clone(LatConst.LAT_VALUE.DEFAULT);
    }
    return { type: this.type, value: this.elements[this.elementIndex++], default: false };
};
LatVarList.prototype.hasNext = function() {
    return this.elementIndex < this.elements.length;
};
LatVarList.prototype.countElements = function() {
    return this.elements.length + 1;
};
LatVarList.prototype.restart = function() {
    this.elementIndex = 0;
    this.first = true;
    return this;
};
LatVarList.prototype.changeVariantInAst = function(currentValue) {
    var readOnly = true;
    for(var i = 0; i < this.varrefs.length; i++){
        if(this.varrefs[i].useExpr.use == LatConst.VAR_USES.WRITE || this.varrefs[i].useExpr.use == LatConst.VAR_USES.READWRITE){
            readOnly = false;
            break;
        }
    }
    if(readOnly){
        LatUtils._warn("only read option in changeVariantInAst is not yet implemented");
        //TODO: basta alterar o vardecl
        //var $temp = this.vardecl;
        //$temp.replace(%{[[currentValue.value]]}%);
    }else{
        //TODO: move the for here after implementing readonly
        println("read only is not yet implemented, but when it is this message should not appear");
    }
    for(var i = 0; i < this.varrefs.length; i++){
        if(this.varrefs[i].use == LatConst.VAR_USES.READ){
            var $temp = this.varrefs[i];
            $temp.replace(%{[[currentValue.value]]}%);
        }
    }
    return this;
};