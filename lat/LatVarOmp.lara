var LatVarOmp = function(name, scheduleTypes, scheduleChunkSize, numThreads, type) {
    LatVar.call(this, name, type);
    //types allowed: dynamic, static, guided, auto, runtime
    this.scheduleTypes = scheduleTypes;
    //check these are LatVarRange or LatVarList
    if (scheduleChunkSize === undefined) {
        scheduleChunkSize = new LatVarList("", [undefined]);
    }
    LatUtils.checkLatVarRangeOrList(scheduleChunkSize, "scheduleChunkSize");
    if (numThreads === undefined) {
        numThreads = new LatVarList("", [0]);
    }
    LatUtils.checkLatVarRangeOrList(numThreads, "numThreads");
    this.scheduleChunkSize = scheduleChunkSize;
    this.numThreads = numThreads;
    this.pragma = undefined; //specific for each variant so it is only loaded inside .puhs/.pop
    this.generateOmpVariants();
    this.restart();
};

LatVarOmp.prototype = Object.create(LatVar.prototype);
LatVarOmp.prototype.constructor = LatVarOmp;

//Functions overloaded from LatVar
LatVarOmp.prototype.getNext = function() {
    if (this.first) {
        this.first = false;
        return LatUtils.clone(LatConst.LAT_VALUE.DEFAULT);
    }
    return { type: this.type, value: this.variants[this.elementIndex++], default: false };
};
LatVarOmp.prototype.hasNext = function() {
    return this.elementIndex < this.variants.length;
};
LatVarOmp.prototype.countElements = function() {
    return this.variants.length;
};
LatVarOmp.prototype.restart = function() {
    this.elementIndex = 0;
    this.first = true;
    return this;
};

//specific functions
LatVarOmp.prototype.generateOmpVariants = function() {
    this.variants = [];
    //{scheduleType: , scheduleChunkSize: , numThreads: }
    for (var i = 0; i < this.scheduleTypes.length; i++) {
        this.scheduleChunkSize.getNext(); //ignore default chunk size
        while (this.scheduleChunkSize.hasNext()) {
            var chunkSize = this.scheduleChunkSize.getNext().value;
            this.numThreads.getNext(); //ignore num threads default
            while (this.numThreads.hasNext()) {
                this.variants.push({
                    scheduleType: this.scheduleTypes[i],
                    scheduleChunkSize: chunkSize,
                    numThreads: this.numThreads.getNext().value
                });
            }
            this.numThreads.restart();
        }
        this.scheduleChunkSize.restart();
    }
    return this;
};
LatVarOmp.prototype.generateContent = function(currentValue) {
    println(JSON.stringify(currentValue));
    var newContent = this.pragma.content;

    if (currentValue.scheduleChunkSize === undefined) {
        newContent += " schedule(" + currentValue.scheduleType + ")";
    } else {
        newContent += " schedule(" + currentValue.scheduleType + "," + currentValue.scheduleChunkSize + ")";
    }
    if (currentValue.numThreads > 0) {
        newContent += " num_threads(" + currentValue.numThreads + ")";
    }
    return newContent;
};

LatVarOmp.prototype.changeVariantInAst = function(currentValue) {
    currentValue = currentValue.value;
    this.pragma.setContent(this.generateContent(currentValue));
    this.pragma.setName("omp");
};